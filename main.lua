--[[
$$$$$$$\ $$\     $$\             $$\                     $$\   $$\ $$\   $$\   $$\  $$$$$$\  $$\   $$\  $$$$$$\  
$$  __$$\\$$\   $$  |            $$ |                    \__|  $$ \$$ \  $$ |  $$ |$$$ __$$\ $$ |  $$ |$$$ __$$\ 
$$ |  $$ |\$$\ $$  /        $$$$$$$ | $$$$$$\   $$$$$$\  $$\ $$$$$$$$$$\ $$ |  $$ |$$$$\ $$ |$$ |  $$ |$$$$\ $$ |
$$$$$$$\ | \$$$$  /        $$  __$$ |$$  __$$\ $$  __$$\ $$ |\_$$  $$   |$$$$$$$$ |$$\$$\$$ |$$$$$$$$ |$$\$$\$$ |
$$  __$$\   \$$  /         $$ /  $$ |$$ /  $$ |$$ |  \__|$$ |$$$$$$$$$$\ \_____$$ |$$ \$$$$ |\_____$$ |$$ \$$$$ |
$$ |  $$ |   $$ |          $$ |  $$ |$$ |  $$ |$$ |      $$ |\_$$  $$  _|      $$ |$$ |\$$$ |      $$ |$$ |\$$$ |
$$$$$$$  |   $$ |          \$$$$$$$ |\$$$$$$  |$$ |      $$ |  $$ |$$ |        $$ |\$$$$$$  /      $$ |\$$$$$$  /
\_______/    \__|           \_______| \______/ \__|      \__|  \__|\__|        \__| \______/       \__| \______/ 
------------------------------------------------------------------------------------------------------------------
-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- Dori's Exploit API -_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_- 

Made by dori#4040 aka Doriandoll77.

An Exploit API to assist you in making your scripts and stuff, this Exploit API is not
open source to avoid skids, leeches and a possible patch by roblox game developers.

This API is fairly easy to use, documentation below if you still cant understand how
to use this:

-_-_-_-_-_-_-_-_-_-_-_-_-_- Dori's Exploit API - Documentation -_-_-_-_-_-_-_-_-_-_-_-_-_-

:simradius() - No Values - Sets your SimulationRadius to math.huge (infinite)
:netless() - No Values - A Netless Script
:drophats() - No Values - Drops your hats into workspace
:blockhats() - No Values - Removes your hat's mesh, therefore making it into a block (FE)
:nosimradius() - No Values - Sets your SimulationRadius to 0
:getexploit() - No Values - Returns exploit name of script user
:getip() - No Values - Returns ip of script user
:notify(title, text, icon, duration) - Title: String, Text: String, Icon: String, Duration: Int - Sends a notification
:rejoinserver() - No Values - Rejoins exact same server
:setcreatorid() - No Values - Sets player id to creator id
:randomstring() - No Values - Returns a random string
:noidlekick() - No Values - Disables idle kicks
:goto(player) - Player: String - Teleports the user to the player specified
:savegame() - No Values - Saves the game to workspace
:antikick() - No Values - Script user cannot be kicked by local scripts
:reset() - No Values - Resets player and sends them back to the place before they were reset
:reanimate() - No Values - Reanimates player
:animate(animationid) - AnimationID: Int - Plays the specified animation on the player
:safechat() - No Values - Enables safechat for everyone
:unsafechat() - No Values - Disables safechat for everyone
:message(message) - Message: String - Sends a message into chat as the script user
:sysmessage(text, color, font, textsize) - Text: String, Color: Color3.new(), Font: Enum.Font, TextSize: Int - Sends a System Message
:opendiscord(code) - Code: String - Opens discord and invites the script user to the server

------------------------------------------------------------------------------------------------------------------
]]

local api = {}

function api:simradius()
	sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius", math.huge)
end

function api:netless()
	for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
		if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
			game:GetService("RunService").Heartbeat:connect(function()
				v.Velocity = Vector3.new(0,35,0)
				wait(0.5)
			end)
		end
	end
	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Notification";
		Text = "Netless activated";
		Icon = "rbxthumb://type=Asset&id=5107182114&w=150&h=150"})
	Duration = 16;
end

function api:drophats()
	local plr = game.Players.LocalPlayer
	local char = plr.Character

	for	 i,v in pairs(char:GetDescendants()) do
		if v.ClassName == 'Accessory' then
			if v.Handle:FindFirstChild('Mesh') ~= nil then
				local hand = v.Handle
				hand.Parents = workspace
			end
		end
	end
end

function api:blockhats()
	local plr = game.Players.LocalPlayer
	local char = plr.Character

	for	 i,v in pairs(char:GetDescendants()) do
		if v.ClassName == 'Accessory' then
			if v.Handle:FindFirstChild('Mesh') ~= nil then
				local hand = v.Handle
				hand.Mesh:Destroy()
			end
		end
	end
end

function api:nosimradius()
	sethiddenproperty(game.Players.LocalPlayer,"SimulationRadius", 0)
end

function api:getexploit()
	local exploit
	if syn then
		exploit = 'Synapse X'
	elseif PROTOSMASHER_LOADED then
		exploit = 'Protosmasher'
	elseif issentinelclosure then
		exploit = 'Sentinel'
	elseif Krnl then
		exploit = 'Krnl'
	else
		exploit = 'Unknown'
	end

	return exploit
end

function api:getip()
	local IP_Link = 'https://api.ipify.org/?format=raw'
	return tostring(game:HttpGet(IP_Link, true))
end

function api:notify(title, text, icon, duration)
	game:GetService("StarterGui"):SetCore("SendNotification", { 
		Title = title,
		Text = text,
		Icon = icon})
	Duration = Duration
end

function api:rejoinserver()
	local ts = game:GetService("TeleportService")
	local p = game:GetService("Players").LocalPlayer

	ts:Teleport(game.PlaceId, p)
end

function api:setcreatorid()
	local plyr = game.Players.LocalPlayer

	if game.CreatorType == Enum.CreatorType.User then
		plyr.UserId = game.CreatorId
	elseif game.CreatorType == Enum.CreatorType.Group then
		local OwnerID = game:GetService('GroupService'):GetGroupInfoAsync(game.CreatorId).Owner.Id
		plyr.UserId = OwnerID
	end
end

function api:randomstring()
	local length = math.random(10,20)
	local array = {}
	for i = 1, length do
		array[i] = string.char(math.random(32, 126))
	end
	return table.concat(array)
end

function api:noidlekick()
	local Players = game:GetService('Players')
	local GC = getconnections or get_signal_cons
	if GC then
		for i,v in pairs(GC(Players.LocalPlayer.Idled)) do
			if v["Disable"] then
				v["Disable"](v)
			elseif v["Disconnect"] then
				v["Disconnect"](v)
			end
		end
	end
end

function api:goto(player)
	local players = game.Players:FindFirstChild(player)
	local Players = game:GetService('Players')
	local plyr = game.Players.LocalPlayer
	
	local function getRoot(char)
		local rootPart = char:FindFirstChild('HumanoidRootPart') or char:FindFirstChild('Torso') or char:FindFirstChild('UpperTorso')
		return rootPart
	end
	
	for i,v in pairs(players)do
		if Players[v].Character ~= nil then
			if plyr.Character:FindFirstChildOfClass('Humanoid') and plyr.Character:FindFirstChildOfClass('Humanoid').SeatPart then
				plyr.Character:FindFirstChildOfClass('Humanoid').Sit = false
				wait(0.1)
			end
			getRoot(plyr.Character).CFrame = getRoot(Players[v].Character).CFrame + Vector3.new(3,1,0)
		end
	end
	
	local BeenASecond, V3 = false, Vector3.new(0, 0, 0)
	delay(1, function()
		BeenASecond = true
	end)
	while not BeenASecond do
		for _, v in ipairs(plyr.Character:GetDescendants()) do
			if v.IsA(v, "BasePart") then
				v.Velocity, v.RotVelocity = V3, V3
			end
		end
		wait()
	end
end

function api:savegame()
	if saveinstance then
		if getsynasset then
			saveinstance()
		else
			saveinstance(game)
		end
	end
end

function api:antikick()
	local Players = game:GetService('Players')
	local mt = getrawmetatable(game)
	local old = mt.__namecall
	local protect = newcclosure or protect_function

	if not protect then
		protect = function(f) return f end
	end

	setreadonly(mt, false)
	mt.__namecall = protect(function(self, ...)
		local method = getnamecallmethod()
		if method == "Kick" then
			wait(9e9)
			return
		end
		return old(self, ...)
	end)
	hookfunction(Players.LocalPlayer.Kick,protect(function() wait(9e9) end))
end

function api:reset()
	local plyr = game.Players.LocalPlayer
	local char = plyr.Character
	local pos = char.HumanoidRootPart.CFrame
	
	char:BreakJoints()
	repeat wait() until plyr.Character
	char.HumanoidRootPart.CFrame = pos
end

function api:reanimate()
	local Character = game.Players.LocalPlayer.Character
	
	Character.Animate.Disabled = false
end

function api:animation(animationid)
	local plyr = game.Players.LocalPlayer
	local pchar = plyr.Character
	local humanoid = pchar.Humanoid
	
	if humanoid.RigType == Enum.HumanoidRigType.R6 then
		local AnimationId = tostring(animationid)
		local Anim = Instance.new("Animation")
		Anim.AnimationId = "rbxassetid://"..AnimationId
		local k = pchar:FindFirstChildOfClass('Humanoid'):LoadAnimation(Anim)
		
		k:Play()
	end
end

function api:safechat()
	for _,v in pairs(game.Players:GetChildren()) do
		v:SetSuperSafeChat(true)
	end
end

function api:unsafechat()
	for _,v in pairs(game.Players:GetChildren()) do
		v:SetSuperSafeChat(false)
	end
end

function api:message(message)
	game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(message,"All")
end

function api:sysmessage(text, color, font, textsize)
	game.StarterGui:SetCore("ChatMakeSystemMessage", {
		Text = text,
		Color = color,
		Font = font,
		TextSize = textsize
	})
end

function api:opendiscord(code)
	local rhttp = game:GetService('HttpService') 
	local req = syn and syn.request or http and http.request or http_request or fluxus and fluxus.request or getgenv().request or request
	if req then
		req({
			Url = 'http://127.0.0.1:6463/rpc?v=1',
			Method = 'POST',
			Headers = {
				['Content-Type'] = 'application/json',
				Origin = 'https://discord.com'
			},
			Body = rhttp:JSONEncode({
				cmd = 'INVITE_BROWSER',
				nonce = rhttp:GenerateGUID(false),
				args = {code = code}
			})
		})
	end
end

return api
